import React from 'react';
import './LessonStyles.css';

const BinaryIntro = () => {
  return (
    <div className="lesson-page">
      <h1>Introduction to Buffer Overflow: The Dangerous gets() Function</h1>
      <div className="lesson-content">
        <section>
          <h2>My First Encounter with Buffer Overflows</h2>
          <p>Let me tell you about the day I accidentally crashed my friend's demo program during a C programming class. I was just trying to input my ridiculously long name, and suddenly—<strong>SEGMENTATION FAULT</strong>. My friend stared at me in disbelief. That's when I learned about one of the most notorious functions in C: <code>gets()</code>.</p>
        </section>

        <section>
          <h2>What is a Buffer Overflow?</h2>
          <p>Think of a buffer like a parking lot with exactly 10 spaces. A buffer overflow is like trying to park 15 cars in those 10 spaces—the extra cars spill over into the neighboring area, potentially causing chaos. In programming terms, it's when data exceeds the allocated memory space and overwrites adjacent memory locations.</p>
        </section>

        <section>
          <h2>The Culprit: gets() Function</h2>
          <p>The <code>gets()</code> function reads a line from standard input and stores it in a buffer. Sounds innocent, right? <strong>WRONG.</strong> Here's why it's considered one of the most dangerous functions in C:</p>
          
          <div className="code-block">
            <pre>
{`char buffer[50];
gets(buffer);  // This is a ticking time bomb!`}
            </pre>
          </div>
          
          <p>The problem? <code>gets()</code> has <strong>no bounds checking</strong>. It doesn't care if your buffer can hold 50 characters—if you input 100 characters, it'll happily write all 100, obliterating whatever was stored in the memory after your buffer.</p>
        </section>

        <section>
          <h2>A Simple Example That Shows the Problem</h2>
          <p>Let me show you a vulnerable program I wrote during my learning journey:</p>
          
          <div className="code-block">
            <pre>
{`#include <stdio.h>
#include <string.h>

void vulnerable_function() {
    char buffer[64];
    printf("Enter your name: ");
    gets(buffer);  // The dangerous line
    printf("Hello, %s!\\n", buffer);
}

int main() {
    vulnerable_function();
    return 0;
}`}
            </pre>
          </div>

          <h3>What Happens When Things Go Wrong?</h3>
          <ol>
            <li><strong>Normal input:</strong> "Alice" → Everything works fine</li>
            <li><strong>Long input:</strong> "A" repeated 100 times → <strong>CRASH!</strong></li>
          </ol>
          
          <p>When you input more than 64 characters, the excess data overwrites:</p>
          <ul>
            <li>Local variables</li>
            <li>Return addresses</li>
            <li>Function pointers</li>
            <li>Other critical memory locations</li>
          </ul>
        </section>

        <section>
          <h2>Memory Layout</h2>
          <p>Understanding how memory is organized is crucial for buffer overflow exploitation:</p>
          
          <div className="memory-layout">
            <h3>Stack Memory Layout</h3>
            <ul>
              <li><strong>Higher Memory Addresses</strong></li>
              <li>Return Address</li>
              <li>Saved Frame Pointer</li>
              <li>Local Variables (including buffer)</li>
              <li><strong>Lower Memory Addresses</strong></li>
            </ul>
          </div>
        </section>

        <section>
          <h2>Exploitation Techniques</h2>
          <h3>Stack Smashing</h3>
          <p>By overflowing a buffer, we can overwrite the return address and redirect program execution.</p>
          
          <h3>Return-to-libc</h3>
          <p>Instead of injecting shellcode, we can return to existing functions in the system.</p>
          
          <h3>ROP (Return-Oriented Programming)</h3>
          <p>Chaining together small code sequences called "gadgets" to perform complex operations.</p>
        </section>

        <section>
          <h2>Protection Mechanisms</h2>
          <h3>Modern Protections</h3>
          <ul>
            <li><strong>Stack Canaries:</strong> Random values placed before return addresses</li>
            <li><strong>ASLR:</strong> Address Space Layout Randomization</li>
            <li><strong>NX Bit:</strong> Non-executable stack protection</li>
            <li><strong>Stack Guard:</strong> Compiler-based protection</li>
          </ul>
        </section>
      </div>
    </div>
  );
};

export default BinaryIntro;