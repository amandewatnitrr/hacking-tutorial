---
title: "WPA/WPS Hacking"
slug: "wpa_wps_hack"
order: 15
category: "python-scripts"
prev: "wep_wifi_hacking"
next: "wpa2_dictionary_attack"
---

## wpa_wps_hack.py

### Use Case Scenario

This script is a Python wrapper designed to automate the configuration and execution of the specialized external tool **Reaver**, which is used to perform a **WPS (Wi-Fi Protected Setup) brute-force attack** against WPA/WPA2 networks. It is a fundamental tool for **network vulnerability assessments**.

* **What problem does it solve?** It simplifies the workflow for testing a network's resilience to WPS-based attacks. It automates essential setup steps—like retrieving the host's MAC address and setting the wireless interface to the correct channel (`iwconfig` / `ifconfig` calls)—before launching the complex `reaver` command.
* **Who would benefit from using it?** **Security Analysts**, **Penetration Testers**, and **Ethical Hacking students** who need to demonstrate or validate the **WPS vulnerability** on authorized networks. It provides a simple Python interface to execute a multi-step external process.

---

### What the Script Does

The Python script acts as an **orchestrator** for the **Reaver** utility, which attempts to exploit the WPS protocol's design flaw to guess the 8-digit PIN and, subsequently, retrieve the WPA/WPA2 Pre-Shared Key (PSK).

The execution flow is:

1.  **Input:** It gathers three inputs from the user: the **wireless interface name** (e.g., `wlan0`), the **Target MAC address (BSSID)** of the AP, and the target's **Wi-Fi channel**.
2.  **Configuration:** It calls the system commands (`ifconfig`, `iwconfig`) to temporarily disable, configure the wireless channel, and re-enable the specified interface, ensuring it is ready for the Reaver process.
3.  **Process:** It constructs and executes the `reaver` command in a subprocess, passing all necessary parameters (`--bssid`, `--channel`, `--interface`).
4.  **Output/Side Effects:** It prints informative status messages and then **streams the real-time output** from the running `reaver` process directly to the user's console. The primary effect is the execution of the external brute-force attempt, which runs until successful or manually terminated.

---

### Code Explanation

#### Imported Libraries

| Library | Purpose |
| :--- | :--- |
| `subprocess` | **Essential.** Used to execute external system commands (like `ifconfig`, `iwconfig`) and to launch, manage, and stream the output from the `reaver` utility. |
| `re` (Regular Expressions) | Used for **pattern matching** to reliably extract the host interface's MAC address from the raw text output generated by the `ifconfig` command. |

#### Main Functions

| Function | Parameters | Returns | Purpose |
| :--- | :--- | :--- | :--- |
| `get_interface_mac` | `interface` (str) | The MAC address string or `None`. | Executes `ifconfig` for the given interface, uses a regex to search for the MAC address pattern (`unspec\s+([A-Fa-f0-9\-]+)`), formats it with colons, and returns the result. |
| `run_reaver` | `interface` (str), `target_mac` (str), `channel` (str) | None | Constructs the `reaver` command with standard WPS attack flags (`-vvv`, `--no-associate`) and runs it as a subprocess. It uses a loop to read and print the `reaver` output line-by-line in real-time. |
| `wpa_wps_hack` | `interface` (str), `target_mac` (str) | None | The control function. It retrieves the host MAC, prompts for the channel, configures the interface using OS calls, and finally initiates the WPS attack by calling `run_reaver()`. |

#### Execution Logic

The script starts execution in the standard entry point, the **`if __name__ == "__main__":`** block.

1.  **Initial Input:** The user is prompted for the required **wireless interface name** and the **target network's MAC address (BSSID)**.
2.  **Orchestration Call:** The `wpa_wps_hack(interface, target_mac)` function is immediately called.
3.  **Setup Phase:**
    * `get_interface_mac` attempts to find and display the local interface's MAC.
    * The user is prompted to enter the **Wi-Fi channel**.
    * Three system calls are made using `subprocess.call` to configure the interface for the attack: `ifconfig down`, `iwconfig channel`, and `ifconfig up`. This ensures the card is correctly operating on the target's channel.
4.  **Attack Execution:** The `run_reaver` function is called, which launches the `reaver` process.
5.  **Monitoring:** The script enters a `try...finally` block within `run_reaver` to continuously read and print the logs from `reaver`'s `stdout`. This provides real-time feedback to the user.
6.  **Cleanup:** The `finally` block ensures that the `reaver` process is terminated and waited for (`proc.terminate()` and `proc.wait()`) when the user stops the script (e.g., with `Ctrl+C`).
                      
---

### Screenshots

---

### Sequence Diagram

```mermaid
sequenceDiagram
    participant User
    participant Script as wpa_wps_hack.py
    participant OS as Operating System Shell
    participant Reaver as External Tool (reaver)

    User->>Script: Execute Script
    Script->>User: Prompt: Enter interface name
    User->>Script: Provide: interface (e.g., wlan0)
    Script->>User: Prompt: Enter target MAC address (BSSID)
    User->>Script: Provide: target_mac (e.g., AA:BB:CC:DD:EE:FF)

    Script->>Script: Call wpa_wps_hack(interface, target_mac)

    Script->>OS: subprocess.check_output(["ifconfig", interface])
    OS-->>Script: ifconfig Output
    Script->>Script: Parse MAC address (get_interface_mac)

    Script->>User: Prompt: Enter Wi-Fi channel
    User->>Script: Provide: channel (e.g., 6)

    Script->>OS: subprocess.call(["ifconfig", interface, "down"])
    Script->>OS: subprocess.call(["iwconfig", interface, "channel", channel])
    Script->>OS: subprocess.call(["ifconfig", interface, "up"])

    Script->>Script: Call run_reaver(interface, target_mac, channel)
    Script->>OS: subprocess.Popen(["reaver", "--bssid", target_mac, ...])
    OS->>Reaver: Launch Reaver process

    loop Monitor Reaver Output
        Reaver->>Script: Reaver Log Output (via stdout)
        Script->>User: Print log line
    end

    User->>Script: Manual Termination (Ctrl+C)
    Script->>Reaver: Terminate Process (proc.terminate())
    Script->>OS: Process cleanup (proc.wait())
    Script->>OS: Exit
